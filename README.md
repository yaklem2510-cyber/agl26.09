# agl26.09
1)
1. Бинарная куча
· Структура: полное бинарное дерево, хранится в массиве.
· Свойства:
· Min-куча: родитель ≤ потомков.
· Max-куча: родитель ≥ потомков.
· Операции: вставка, извлечение минимума/максимума, удаление.
· Реализация:
· Python: модуль heapq (только min-heap), возможна реализация через класс.
import heapq
· C++: ручная реализация на основе вектора с методами heapifyUp, heapifyDown.
· Java: класс PriorityQueue, либо ручная реализация через массив.
2. Биномиальная куча
· Структура: набор биномиальных деревьев разного размера.
· Особенности: поддерживает слияние куч за O(log n).
· Операции: вставка, извлечение минимума, слияние, уменьшение ключа.
· Реализация:
· C++/Java: реализуется через классы с указателями на деревья.
4. Куча Фибоначчи
· Особенности: амортизировано O(1) для вставки и уменьшения ключа, O(log n) для извлечения минимума.
· Применение: алгоритм Дейкстры, приоритетные очереди с частым изменением ключей.
· Реализация:
· C++/Java: возможна реализация через классы с циклическими списками и поддержкой рангов.
2)
Хеш-таблицы
· Структура: массив бакетов, каждый хранит пары «ключ-значение».
· Коллизии разрешаются:
· Метод цепочек (списки в бакетах).
· Открытая адресация (линейное/квадратичное пробирование).
· Операции: вставка, поиск, удаление (в среднем O(1)).
· Реализация:
· Python: встроенный тип dict.
· C++: std::unordered_map, либо ручная реализация с цепочками.
· Java: HashMap, Hashtable (синхронизирован).

Ключевые моменты про кучи

· Бинарные кучи есть во всех языках, эффективны для приоритетных очередей.
· Биномиальные и Фибоначчиевы кучи требуют внешних библиотек или ручной реализации.
· Хеш-таблицы встроены во все языки и используются для быстрого поиска.

Вывод
· Кучи используются для приоритетных очередей.
· Хеш-таблицы — для быстрого поиска и вставки по ключу.
· Выбор структуры зависит от частоты операций и требований к производительности.
